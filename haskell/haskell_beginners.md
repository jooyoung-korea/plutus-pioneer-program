공부 자료: [WikibooksHaskell](https://wikidocs.net/1570)

# 기초 

## 1. 환경 

<br />

`Prelude>` 부분은 프롬프트라고 하는 것이다. 여기에 명령을 입력하면 GHCi는 그 결과에 응답한다.

GHCi를 떠나려면 `:quit` 또는 `:q`를 입력한다.

        Prelude> :quit
        Leaving GHCi.

<br />

## 2. 변수와 함수 


<br />

하스켈은 <img src="https://latex.codecogs.com/gif.latex?\pi" />  의 15자리까지 보관하는ㄴ `pi`라는 변수를 포함한다. 

<br />

### 변수 정의

아래와 같이 하면 된다. `let`을 사용할 수도 있지만 복잡한 작업에서는 실용적이지 않고, 하스켈은 공백에 민감하므로 시작할 때 공백 없는지 확인하기 

        r = 5.0

<br />

### 파일 불러오기 

        :load homework1.hs
        :l homework1.hs

파일 불러왔으면 GHCi의 프롬프트가 "Prelude"에서 "Main"으로 변한다.

이후에 변수를 저장하고 `:reload` (`:r`) 명령 입력하면, 불러온 파일 내에 저장이 되는 것이다. 

<br />

### 주석(Comment)

`--` 는 그 줄이 끝날 때까지 

`{- ... -}` 는 여러 줄로 확장할 수 있다. 아래와 같이도 사용가능.

        answer = 2 * {-
        block comment, crossing lines and...
        -} 3 {- inline comment. -} * 7

<br />

### 명령형(imperative) 프로그램 vs. 함수형 프로그램

<br />

*명령형 프로그래밍*은 변수를 컴퓨터 메모리 안의 **변경 가능** 장소로 취급하지만, *함수형 프로그래밍*은 수학적 도구를 통해 사고하는 방법을 제공하며, 변수들이 어떻게 서로 연결되어있는지를 정의하고 컴퓨터가 처리할 수 있는 단계별 명령으로 번역하는 일은 컴파일러가 한다.

예시를 하나 보자. 다음 코드는 하스켈에서 작동하지 않는다.

        r = 5
        r = 2

명령형 프로그래머는 이것을 처음에는 r = 5로 설정하고 그 다음 r = 2로 변경한다고 읽을 것이다. 하스켈에서 위 코드는 "r의 중복 선언"이라는 오류를 뱉는다. 주어진 스코프 안에서 한 하스켈 변수는 한번만 정의할 수 있고 변경 불가능하다. 수학 문제 풀 때, 쉬운 예로, <img src="https://latex.codecogs.com/gif.latex?x^2+y^2=25\,\text{,}\,y=4" /> 일때 x값을 구할 때, y를 다시 3으로 정의한다던지 하지 않지 않는가? 하스켈 변수는 **불변 (immutable)** (마치 블록체인에 기입되는 정보와 같이) 그래서 하스켈 프로그램에서는 *일부* 변수들은 코드에 명시하지 않고, 외부 파일, 데이터베이스, 사용자 입력으로부터 데이터를 얻을 때 정의된다. 

<br />

### 재귀적 정의 

        r = r + 1

다른 프로그래밍에서와 달리 앞서 r = 5 라고 정의되면, 6이라고 메모리 값을 갱신하는 것이 아니라, `r`을 이용해 `r`을 정의하는 재귀적 정의 방식이다. 하스켈에서는 x를 y보다 먼저 선언한다 는 개념이 없다. 

        y = x * 2
        x = 3

위와 같은 것이 가능한 것이다. 물론 x를 정의해주지 않으면, y를 사용하진 못한다. (질문) 근데 GHCi에서 쓸 때, 다짜고짜 `y = x * 2` 하면, 

```haskell
<interactive>:7:5: error: Variable not in scope: x
```
이라는데, 이제 소스코드 파일 안에서는 이런 정의가 가능하다는 말인거겠지?


<br />

### 함수 

<br />

함수는 인자argument 값(또는 매개변수parameter)을 취해서 결과 값을 돌려준다. (그 본질은 수학의 함수와 같다) 하스켈에서 함수를 정의하는 것은 변수를 정의하는 것과 비슷하지만 좌변에 함수 인자를 놓는다는 점이 다르다. 예를 들면 다음은 r이라는 인자에 의존하는 함수 area를 정의한다. 수학에서 f(x) 라고 하는 것과 비슷한 느낌. <img src="https://latex.codecogs.com/gif.latex?\text{Area}(r)={\pi}r^2" />  을 하스켈에선 비슷하게, 

        area r = pi * r ^2

함수를 이용할 때 수학에서 Area(5) = 78.54 처럼 괄호를 이용해줄 수도 있지만, 관례에 따르면 생략한다. 여분의 기호를 줄이고자 하는 이유라고 함. 

        area 5 * 3      -- (area 5) * 3
        area (5 * 3)    -- area 15

<br />

### 여러 개의 매개변수 

        areaRect l w = l * w

와 같이 인수들은 공백으로 구분된다.

        double x = 2 * x
        quadruple x = double double x 

아래 `quadruple`은 잘못되었다. 이러면 `double` 이라는 함수를 두 인자 double과 x에 적용하게 된다. 함수도 다른 함수의 인자가 될 수 있다는 것에 유의하라. (그 이유는 곧) 괄호를 써줘야 한다. 

        quadruple x = double (double x)

<br />

### 함수 합성에 관해 

원통의 부피 계산하는 함수를 작성해보자. 원 모양 바닥의 넓이를 계산하는 함수를 작성하고, 그것을 활용해보자.

        areaRect r = pi * r ^ 2
        areaVol r h = h * areaRect r -- 괄호 안해줘도 된다. 

<br />

### 지역 정의(local definition)

`where` 절

함수 정의할 때 중간 결과를 정의하고 싶을 때, 예시로 헤론의 공식을 생각해보자. 
```haskell
heron a b c = sqrt (s * (s - a) * (s - b) * (s - c))
    where
    s = (a + b + c) / 2
```
변수 a, b, c가는 heron 함수의 우변에서만 이용할 수 있지만 여기서 s의 정의는 heron의 우변의 일부가 아니다. s를 우변의 일부로 만들려면 where 키워드를 사용해야 한다.

```haskell
areaTriangleHeron a b c = result           -- use Heron's formula
    where
        result = sqrt (s * (s - a) * (s - b) * (s - c))
        s      = (a + b + c) / 2
```
이런게 된다는 거 같은데 흠 대충은 이해했다!

<br />

### 스코프 (Scope)

아래의 예시를 보자 

```haskell
Prelude> let r = 0
Prelude> let area r = pi * r ^ 2
Prelude> area 5
78.53981633974483
```
함수의 인자로 사용되는 변수는 함수를 호출할 때 입력될 매개변수가 결정하는 것이고, 해당 변수가 정의된 것과는 무관한 것이다. 하지만 변수에 적절한 고유 이름들을 붙여주면 독자가 코드 읽기 편하겠징. 스코프의 기술적인 면면은 to be continued ... 

참고로 함수 명에 문자, 숫자, _, '(따옴표) 가 가능하다고 한다. 단, 시작은 반드시 소문자.


<br />

## 3. 진위값

### 동등 비교와 기타 비교들
<br />

하스켈은 `==`(같음)처럼 작동하는 `<`(미만), `>`(초과), `<=`(이하), `>=`(이상) 등 많은 검사를 제공한다.

<br />

### 불리언 값

- `&&` 은 and 연산(논리곱)을 수행한다. 두 불리언 값이 주어지면, 둘 다 True인 경우 (&&)는 True로 평가되고 그 외의 경우 False로 평가된다.
- `||`은 or 연산(논리합)을 수행한다. 두 불리언 값이 주어지면, 둘 중 하나라도 True인 경우 True로, 그 외의 경우 False로 평가된다.
- `not`은 불리언 값의 반전(negation)을 수행한다. 즉 True는 False로, False는 True로 변환한다.
- 비항등(not equal to)이라는 또다른 관계 연산자가 있다. 이 연산자는 하스켈이 이미 `/=` 라는 함수로 제공하지만 이렇게 직접 구현할 수 있다.
        x /= y = not (x == y)

<br />

### 가드 (guard)

절댓값 함수 구현하는 걸 생각해보자

```haskell
abs x 
    | x < 0     = 0 - x
    | otherwise = x
```

- = 뒤에 바로 정의를 적는 것이 아닌, 두 대체문을 변개의 줄에 놓는다.(가독성을 위해) 이때, 이 대체문들을 가드라고 하고, 공백은 미적인 이유 아니고, 코드가 올바르게 파싱되게 하는 요소임.
- 각각의 가드는 파이프 (`|`) 로 시작하고, 파이프 뒤에는 불리언 값으로 평가되는 표현식(불리언 조건식 혹은 predicate), 그리고 정의에 해당하는 나머지 부분이 온다. 
- otherwise는 선행하는 조건들 중 True가 없을 경우 사용됨, 위의 경우엔 x >= 0 과 동일하다. otherwise는 하스켈의 기본 변수라고 한다. 아주 단순히 

        otherwise = True


가드 술어식은 순차적이기 때문에 선행하는 표현식들이 전부 False이면 otherwise에 도달하게 되는 식이다. 통상 otherwise를 두는 것이 좋은 생각인데, 어떤 입력에 대해 아무 술어식도 참이 아니면 못생긴 런타임 오류가 발생하기 때문이다.

또, 위 예제에서 

        | x < 0 = -x

가능하지만, 하스켈에서 가능한 몇 안되는 기호반전의 특수 사례라고 한다. 

<br />

## where 와 가드

where절은 특히 가드와 함께 쓸 때 편리하다. 2차 방정식 $ax^2 +bx + c = 0$의 (실수인) 해의 개수를 판별식을 이용해 구하는 함수를 살펴보자.

numOfSolutions a b c
    | disc > 0  = 2
    | disc == 0 = 1
    | otherwise = 0
        where
        disc = b^2 - 4*a*c

where 정의는 모든 가드의 스코프 내에 있어서 disc의 표현식을 반복하는 것을 방지한다.


<br />

## 4. 타입의 기초


<br />

- 하스켈에는 모든 타입 이름이 대문자로 시작해야 한다는 규칙이 있다. 
- 모든 표현식의 타입은 :type (짧게는 :t) 이라는 유용한 명령으로 확인할 수 있다. 

        예: GHCi에서 불리언 값의 타입 확인하기
        Prelude> :type True
        True :: Bool
        Prelude> :type False
        False :: Bool
        Prelude> :t (3 < 5)
        (3 < 5) :: Bool

<br />

### 문자와 문자열

즉 리터럴 문자 값은 Char("character"의 줄임말) 타입을 가진다. 하지만 따옴표는 단독 문자(한 철자)에만 기능한다. 실제 텍스트, 즉 문자의 열을 입력하려면 쌍따옴표를 사용한다.

        Prelude> :t 'H'
        'H' :: Char

        Prelude> :t "Hello World"
        "Hello World" :: [Char]

- 하스켈에서는 텍스트 문자열이 문자들의 리스트다.
- String은 [Char]의 동의어로 정의되어 있다

        Prelude> :t "H"
        "H" :: String



### chr와 ord

텍스트는 컴퓨터의 골치거리다. 컴퓨터가 아는 것은 1과 0을 다루는 방법 뿐이다. 이진수로 작업하는 것은 편하지 않기 때문에 사람들은 컴퓨터가 텍스트를 보관할 수단을 만들어냈다. 모든 문자는 일단 숫자로 변환되고, 이 숫자는 이진수로 변환되어 저장된다. 

        chr :: Int  -> Char 
        ord :: Char -> Int


 chr과 ord 함수 호출하려면 두 함수는 기본적으로 이용할 수 없기 때문에 GHCi에서 이것들을 시험해보기 전에 `:module Data.Char`(또는 `:m Data.Char`)로 이것들이 정의된 Data.Char 모듈을 불러와야 한다.

        Prelude> :m Data.Char
        Prelude Data.Char> chr 97
        'a'
        Prelude Data.Char> chr 98
        'b'
        Prelude Data.Char> ord 'c'
        99
        Prelude Data.Char> ord '각'
        44033

고민 

```haskell
f x y = (x + y) > 5
:t f
f :: (Ord a, Num a) => a -> a -> Bool
```
여기서 `Ord`는 뭐지, 두 개 변수를 써서 그런 것 같은데, 순서가 있는 건가?

아, `chr`과 `ord` 가 하는 정확한 일은 나중에 배운다고 한다. 

<br />

## 타입 추론 

<br />

우리가 함수와 변수의 타입을 하스켈에게 알려주지 않으면 **타입 추론**이라는 절차를 통해 그 타입을 *알아낸다*

예제를 보면, 
```haskell
        -- We're deliberately not providing a type signature for this function
        isL c = c == 'l'
```
현식 `c == 'l'`에서 컴파일러는 'l'이 `Char` 값이란 걸 알고, c와 'l'이 (==)에서 항등 비교되고 (==)의 두 인자는 타입이 같아야 하기 때문에, c는 반드시 `Char` 값이어야 한다는 결론이 나온다. 마지막으로, isL c는 (==)의 결과값이기 때문에 `Bool`이어야 한다. GUCCI! 

        예: 타입을 첨부한 isL
        isL :: Char -> Bool
        isL c = c == 'l'

타입 시그니쳐를 포함하지 않으면 하스켈 컴파일러가 이 과정을 통해 발견하는 것이다. 근데 타입 시그니쳐가 선택 사항이라면 왜 신경써야 하는가? 

- 문서화: 코드 읽기 쉽다. 대부분의 함수는 그 이름과 타입만으로 무슨 일을 할지 추측하기에 충분하다.
- 디버깅: 함수에 타입을 달아놓고 변수의 타입이 잘못 입력되면 컴파일러가 "**컴파일 도중**"에 여러분의 함수가 잘못되었음을 알려줄 것이다. (타입 오류로!) 타입 시그너쳐가 없으면 오류 있는 프로그램이 컴파일되고, 컴파일러가 잘못된 타입들을 할당할 수도 있다. 프로그램을 실행하기 전에는 이런 실수를 했다는 걸 알아내지 못할 것이다.

아래 예제는 타입에러가 날 것이다. `+` 연산에 관해 타입이 정의되어 있기 때문

        "hello" + " world" 

문자열 합치는 연산자는 아래와 같다. 

        "hello" ++ " world"


타입들이 실수를 잡아내는 하나의 체계를 형성한다는 발상은 어메이징 한 것이다. 많은 하스켈 프로그래머가 논하기를, 프로그램의 모든 타입 오류를 고치고 컴파일하면 "그냥 잘 돌아가는" 경향이 있다는 것이다. 처음 실행해도 아주 사소한 문제만 발생한다. 런타임 오류는 컴파일이 아니라 실행할 때 여러분의 프로그램이 잘못되는 것으로, 하스켈에서는 다른 언어들보다 훨씬 희귀한 일이다. 이것이 하스켈처럼 강력한 타입 체계를 가지는 것의 커다란 이점이다.

<br />

## 5. 리스트와 튜플

지금부턴 파이썬과 비슷한 부분은 빨리빨리 읽고 넘어가야겠다. 어느세월에 모나드 배울지...

### 리스트 
---

- 리스트 내의 모든 원소가 타입이 같아야 한다는 것이다. 타입이 혼재된 원소들의 리스트를 정의하려고 하면 전형적인 타입 오류가 발생한다.
- 문자열("Blabla")은 리스트일 뿐

        Prelude>"hey" == ['h','e','y']
        True
        Prelude>"hey" == 'h':'e':'y':[]
        True

### 컨싱(consing)

빈 리스트 [] 혹은 하나의 숫자/철자를 시작으로 다른 리스트를 컨싱할 수 있는 듯하다. 리스트에 리스트를 컨싱하고 싶으면, cons 연산자 `:`(이것도 하나의 함수이다) 오른쪽에 해당하는 리스트는 리스트를 가진 리스트여야하는 것이다. 

<br />

### 튜플 
---

- 튜플은 고정된 개수의 원소들을 가진다(변경불가능immutable). 튜플에 cons할 수는 없다. 따라서 몇 개의 값이 저장될지 미리 아는 경우에 튜플을 사용하는 것이 타당하다. 
- 튜플의 원소들은 같은 타입일 필요가 없다. 

        (4, 5, "Six", True, 'b')

> 리스트 프로그래머들은 한 원소를 리스트의 앞에 추가하는 이 특정한 작업을 칭하는 "to cons"라는 동사를 발명했다. "cons"는 "constructor"의 연상 기호로서, 나중에 이게 왜 타당한지 볼 것이다.

<br />

### 값 획득하기 

`fst`와 `snd`는 짝(2-튜플)의 첫 번째와 두 번째 원소를 획득한다. fst와 snd는 짝만을 인수로 받아들인다.

        Prelude> fst (True, "boo")
        True
        Prelude> snd (5, "Hello")
        "Hello"

리스트의 경우엔 비슷한 `head`와 `tail`이 있는데, head는 리스트의 첫 번째 원소로 평가되고, tail은 리스트의 나머지를 돌려준다. head, tail은 빈 리스트에 적용할 수 없다. 

        Prelude> head [2,7,5,0]
        2
        Prelude> tail [2,7,5,0]
        [7,5,0] 

<br />

### 다형성 타입 

리스트의 길이를 알아내는 함수를 상상해보자. 하지만 [Int], [Bool], [String]의 타입이 모두 다르기 때문에 각각 별도의 함수가 필요한 것 같다. lengthInts :: [Int] -> Int, 그리고 lengthBools :: [Bool] -> Int, 또 lengthStrings :: [String] -> Int, ...

다행히도 모든 리스트에 작동하는 length라는 단일 함수가 있다. 하지만 이게 어떻게 가능할까? 평소대로 length의 타입을 확인해보면 무언가 다른 일이 벌어지고 있다는 좋은 힌트를 줄 것이다.

        예: 첫 번째 다형성 타입
        Prelude>:t length
        length :: [a] -> Int

각괄호 안의 a는 타입이 아니다. 타입 이름은 대문자로 시작하지 않는다. 이것은 **타입 변수**다. 하스켈은 타입 변수의 자리에 *아무 타입*이나 들어가는 것을 허용한다. 바로 우리가 원한 것이다. 타입 이론(수학의 한 갈래)에서는 이것을 다형성polymorphism이라 부른다. 단일 타입만을 가지는 함수나 변수는 단일형monomorphic이라 하고, 하나보다 많은 타입을 허용하기 위해 타입 변수를 사용하는 것들은 다형성polymorphic이라 한다.
따라서 

        f :: a -> a

는 f가 임의 타입의 인자를 취해 인자와 같은 타입의 무언가를 반환한다는 뜻이고, 

        fst :: (a, a) -> a

fst가 짝의 첫 번째와 두 번째 원소가 같은 타입일 때만 작동한다는 뜻이다. 실제로는 아래와 같다. 

        예: fst와 snd의 타입
        fst :: (a, b) -> a
        snd :: (a, b) -> b

<br />

## 6. 타입의 기초2

<br />

### Num 클래스 

`+` 함수의 타입은 무엇이어야 할까? (+)의 시그너쳐는 단순히

        (+) :: Number -> Number -> Number

인 느낌인건 easy하지만 정수가 아닌 실수인 경우엔 컴퓨터가 산수하는 방식에 이게 잘 들어맞지 않는다고 한다. 우리는 (+) 가 정수와 실수 모두에 작동한다는 걸 안다하자. 그럼

        (+) :: a -> a -> a

이건가? 근데 그럼 두 Bool도, 두 Char도 더할 수 있다는 건데 그다지 말이 되지 않는 것 같다. 대신 (+)의 실제 시그너쳐는 한 언어 특성을 활용하는데, 이 특성은 `a`가 *숫자 타입인 한* 어느 타입이든 될 수 있다고 의미상 제한을 거는 것을 가능케 한다.

        (+) :: (Num a) => a -> a -> a

`Num`은 타입클래스로, 숫자로 간주되는 모든 타입을 아우르는, 타입들의 모임이다.3 시그너쳐의 `(Num a) =>` 부분은 `a`를 숫자형으로, 좀 더 정확하게는, `Num`의 인스턴스들으로 제한한다.

<br />

### 숫자 타입들 


- `Int`는 대부분 언어의 그 정수 타입에 대응한다. 컴퓨터의 프로세서에 따라 고정된 최댓값과 최솟값을 가진다. (32비트 기계에서는 -2147483648에서 2147483647까지)
- `Integer`도 정수를 위해 쓰이지만 `Int`와 달리 효율성을 조금 희생해서 임의 크기의 값을 지원한다.
- `Double`은 배정밀도 부동소수점 타입으로, 대다수의 경우 실수를 위한 좋은 선택이다. (`Float`이라고 Double의 단정밀도 친구가 있는데 정밀도의 추가 손실 때문에 대개는 Double에 밀린다)


        Prelude> :t (-7)
        (-7) :: (Num a) => a

이것보게, (-7)은 Int도 Integer도 아니다! 대신 이것은 다형성 상수로서, 필요한 어느 숫자 타입으로든 "변할 수" 있다. 그 이유는 다른 숫자를 살펴보면 명확해진다.

        Prelude> :t 5.12
        5.12 :: (Fractional t) => t

5.12도 다형성 상수(`Num`)인데 Num보다 제한적인 Fractional 클래스에 속하는 것이다. 모든 Fractional은 Num이지만 모든 Num이 Fractional인 것은 아니다(가령 Int와 Integer는 Fractional이 아니다)

        (/) :: (Fractional a) => a -> a -> a

        Prelude> 4 / 3
        1.3333333333333333

4와 3은 다형성 상수고 (/)의 요구에 따라 Double 타입으로 간주되기 때문에 가능한 것이다. 하지만 아래의 경우를 생각해보자. 

        Prelude> 4 / length [1,2,3]

에러가 난다. length의 타입 시그너쳐를 보면 이해될 것이다. 

        length :: [a] -> Int

하지만 이 문제에서 탈출하는 수단을 제공하는 편리한 함수가 있다! 

        fromIntegral :: (Integral a, Num b) => a -> b

`fromIntegral`은 `Integral` 타입(`Int`나 `Integer` 등)의 무언가를 인자로 취해서 다형성 상수로 만든다. length와 결합하면 리스트의 길이를 (/)의 시그너쳐에 맞출 수 있다.

        Prelude> 4 / fromIntegral (length [1,2,3])
        1.3333333333333333

<br />

### 숫자 너머의 클래스 

        (==) :: (Eq a) => a -> a -> Bool

(+)나 (/)처럼 (==)도 다형성 함수(두 가지 이상의 타입을 가질 수 있는 함수이면, f a = a -> a 이런 거나 타입 클래스를 지정해준 함수면 다형성 함수가 되는 건가?)다. (==)는 같은 타입의 두 값을 비교해 `Bool` 값을 반환하는데, 이 두 값은 반드시 `Eq` 클래스에 속해야 한다. `Eq`는 항등 비교가 가능한 값들의 타입들의 클래스이며 모든 기본적인 비함수형 타입들이 여기에 포함된다


### if/then/else

        예: signum 함수 - 이미 하스켈에 정의되어 있다. 
        mySignum x =
            if x < 0 
                then -1
                else if x > 0
                    then 1
                    else 0

다음과 같이 실험해볼 수 있다. 

        *Main> mySignum 5
        1
        *Main> mySignum 0
        0
        *Main> mySignum (5-10)
        -1
        *Main> mySignum (-1)
        -1

마지막의 "-1"을 감싼 괄호는 필수사항이다. 빼먹으면 시스템은 여러분이 mySignum에서 1을 빼려 한다고 생각할 것이고, 이건 타입 불량이다.

위와 같은 if / then / else 함수 정의는 이전 과목에서 소개한 가드 문법으로 쉽게 재작성할 수 있다.

        mySignum x
            | x < 0     = -1
            | x > 0     = 1
            | otherwise = 0

<br />

### 패턴 매칭의 도입

경주자들이 각 경주에서의 순위에 따라 점수를 받는 경쟁에서 통계치를 추적하는 프로그램을 작성한다고 치자. 점수 규칙은 이렇다.

- 승자는 10점
- 2등은 6점
- 3등은 4점
- 4등은 3점
- 5등은 2점
- 6등은 2점
- 나머지는 0점


아래 예제들을 보며 직관적으로 이해해보자

        예: if/then/else로 점수 세기
        pts :: Int -> Int
        pts x =
            if x == 1
                then 10
                else if x == 2
                    then 6
                    else if x == 3
                        then 4
                        else if x == 4
                            then 3
                            else if x == 5
                                then 2
                                else if x == 6
                                    then 1
                                    else 0

흉물스럽다. 더 나은 방법은 

        예: 조각 함수 정의로 점수 세기
        pts :: Int -> Int
        pts 1 = 10
        pts 2 = 6
        pts 3 = 4
        pts 4 = 3
        pts 5 = 2
        pts 6 = 1
        pts _ = 0

훨씬 낫다. 하지만, pts를 이런 식으로 정의하면(지금부터 임의로 조각 정의라고 부르자) 코드를 읽는이에게 함수가 무엇을 하는지 놀랍도록 깔끔히 보여줄 수 있는 건 맞는데, 그 문법은 우리가 지금까지 본 그 하스켈이라기엔 기이하다. 위의 예제는 패턴 매칭이라는, 하스켈의 핵심 특성과의 첫 만남이다. 코드는 알겠는데 맥락을 잘 이해 못함. 

완전 같은 함수는 아닐테지만 아래와 같은 방법도 가능하다는 거

        pts :: Int -> Int
        pts 1 = 10
        pts 2 = 6
        pts x
            | x <= 6    = 7 - x
            | otherwise = 0

정수 외에도 패턴 매칭은 여러 타입의 값과 작동한다. 

        예: (||)
        (||) :: Bool -> Bool -> Bool
        False || False = False
        _     || _     = True

패턴 매칭 쓸 때 주의할 점은 

- 모든 것에 일치하는 패턴(pts 예제의 마지막 패턴 같은 것)을 더 구체적인 패턴의 앞에 놓으면 후자는 무시된다. 그런 경우 GHC(i)는 "패턴 매칭이 중복됨Pattern match(es) are overlapped" 이라 경고할 것이다.
- 일치하는 패턴이 하나도 없으면 오류가 발생한다. 통상 패턴들이 모든 경우를 다루도록 하는 게 좋은 생각인데, `otherwise` 가드가 필수는 아니지만 강력히 권장되는 것과 같다.

<br />

### let 바인딩 

$ax^2+bx+c$꼴의 다항식의 해를 구하는 문제를 보자. x의 두 값을 계산하는 다음 함수를 작성할 수 있다. 

        roots a b c =
            ((-b + sqrt(b*b - 4*a*c)) / (2*a),
            (-b - sqrt(b*b - 4*a*c)) / (2*a))

반복되는 항을 두 번씩 쓰는 건 성가시기 때문에, `where` 또는 `let`을 선언하여 지역 바인딩을 이용할 수 있다. `let` 키워드를 선언 앞에 놓고, `in`을 이용해 함수의 "주" 몸체로 돌아온다는 신호를 보낸다. 하나의 `let...in` 블록 내에 여러 선언을 놓을 수 있다. 이것들이 같은 양만큼 들여쓰기 되었는지만 확실히 할 것. 그렇지 않으면 문법 오류가 발생한다.

        roots a b c =
            let sdisc = sqrt (b*b - 4*a*c)
                twice_a = 2*a
            in  ((-b + sdisc) / twice_a,
                (-b - sdisc) / twice_a)


<br />

## 8. 어휘 쌓기 

<br />

### Prelude와 라이브러리들 

공백으로 구분된 낱말들로 이루어진 문자열을 취해 낱말들의 순서를 뒤집은 문자열을 반환하는 함수가 필요하다고 치자. 즉 "Mary had a little lamb"는 "lamb little a had Mary"이 된다.

다음의 `Prelude` 함수들을 활용하면 easy하게 만들 수 있다.

- `words` 함수. 문자열을 공백으로 구분된 낱말들로 믿을 만하게 쪼개서 문자열들의 리스트를 반환한다.
- `reverse` 함수. 리스트를 뒤집는다(우연히도 위의 reverseList가 하는 일이다).
- `unwords` 함수. words의 반대되는 일을 한다.

        예: 하스켈식 revWords
        revWords :: String -> String
        revWords input = (unwords . reverse . words) input

여기서 . 은 함수 합성할 때 사용하는 . 이다 


<br />

## 9. 간단한 입출력



putStrLn은 표준 Prelude 함수다. 이름에서 putStr 부분이 암시하듯이 이 함수는 String 값을 인자로 취해 그걸 화면에 표시한다. "Ln"은 이 함수가 줄바꿈도 출력한다. 

        Prelude> putStrLn "Hello, World!"
        Hello, World

"putStrLn 함수의 타입이 뭘까?" GHCi가 뭐라고 하는지 보자.

        Prelude> :t putStrLn
        putStrLn :: String -> IO ()

"IO"는 "입력input과 출력output"을 뜻한다. 타입에 `IO`가 들어가면 프로그램 외부 세상과의 상호작용이 수반된다. 우리는 `putStrLn`의 결과값 같은 `IO` 값을 *액션*이라 부를 것이다. IO 타입의 다른 부분, 이 경우 ()는 액션의 결과값의 타입이다. 즉 액션이 프로그램에 돌려주는 무언가의 타입이다(프로그램 바깥에서 하는 일과 반대로). ()는 ("유닛"이라 함) 단일 값을 가지는 재미없는 타입인데, 그 값도 ()라 부른다. putStrLn은 세상에 출력을 보내지만 프로그램에 아무 것도 돌려주지 않기 때문에, ()는 자리를 찜하는 용도다. IO ()를 "()를 반환하는 액션"이라 읽을 수 있겠다. 


우리가 알아야 하는 것은 완전한 하스켈 프로그램이 사실은 실행하고 나면 거대한 IO 액션으로서 가동된다는 것이다. 이 액션은 main이라 부르고, 그 타입은 IO ()다. 이런 관점에서 보면 하스켈 프로그램을 작성한다는 것은 액션과 함수를 결합하여, 총체적인 함수 main을 형성하는 것이다. 그리고 프로그램을 켜면 main이 실행된다.

<br />

### do로 액션들 연계하기 

`do` 표기는 액션들을 함께 놓는 편리한 수단을 제공한다. 

        예: 이름이 뭐에요?
        main = do
        putStrLn "Please enter your name: "
        name <- getLine
        putStrLn ("Hello, " ++ name ++ ", how are you?")


`getLine`은 바깥 세상, 이 경우 터미널로 나가서 `String`을 하나 가져온다. 그 타입은 뭘까?

        Prelude> :t getLine
        getLine :: IO String


함수는 인자를 취해 결과를 반환하는 걸 반영하는 a -> b 식의 타입을 가지는데 getLine은 인자를 취하지 않는다. getLine은 터미널의 무엇이든 그걸 입력으로 취한다. 하지만 바깥 세상의 그 줄은 타입을 가진 값이 될 수 없는데 아직 하스켈 내부에 있는 것도 아니기 때문이다! 

이름 프로그램에서 우리는 세 개의 액션을 연계했다. 인삿말을 출력하는 putStrLn, 그 다음 getLine, 또다시 putStrLn. getLine에선 <- 표기를 썼는데, 이는 액션의 결과값을 얻어오는 수단이다. 그리고 이 값을 다른 데에서 쓸 수 있다(이 경우 최종 메시지 출력을 준비하기 위해). 마지막 액션은 putStrLn의 결과이고 따라서 IO 타입을 가진다.

> 연습문제
> 
> 사용자에게 직각삼각형의 밑변과 높이를 요청해서 그 넓이를 계산해 화면에 출력하는 프로그램을 작성하라. 이 상호작용은 다음과 같아야 한다.
>
>        The base?
>        3.3
>        The height?
>        5.4
>        The area of that triangle is 8.91
> 힌트: `read` 함수를 사용해서 "3.3" 같은 사용자 문자열을 숫자 3.3으로 변환하고 `show` 함수로 숫자를 문자열로 반환할 수 있다.

흠.
```haskell
:{
main = do
    putStrLn "The base?"
    base <- read getLine -- getLine 하고 다음 줄에 read해야하나
    putStrLn "The height?"
    height <- read getLine 
    -- triArea라는 변수에다 넓이를 미리 계산해고 아래에 넣으려면 <- 쓰나 let쓰나  
    putStrLn "The area of that triangle is " ++ show(0.5 * base * height)
:}
```
아닐까? 아닌 거 같다. 다시 해보기... 쉬워 보였는데 금방 안된다! 😭 아래 내용들을 참고해서 좀 이따 다시 시도해보자. 

<br />

### 왼쪽 화살표

        name <- getLine

"getLine을 실행한다. 그리고 그 결과를 name이란 변수에 넣는다" 라는 것임. `<-` 생략하면 액션을 발생하지만 그 데이터는 어디에도 저장되지 않는다. 

         x <- putStrLn "Please enter your name: "

변수 `x`는 액션으로부터 값을 얻어오지만, 이 경우엔 쓸모가 없는게, 이 액션은 유닛 `()`을 반환하기 때문이다. 

하지만 `<-` 는 마지막 액션에선 사용할 수 없다. 아래와 같이 시도하면, 

        main = do
        x <- putStrLn "Please enter your name: "
        name <- getLine
        y <- putStrLn ("Hello, " ++ name ++ ", how are you?")

오류다!

```haskell
The last statement in a 'do' construct must be an expression
```
이 예시는 훨씬 흥미롭지만 지금보다 하스켈을 깊게 이해해야 한다. 대략 말하자면 <-를 써서 액션에서 값을 얻을 때, 하스켈은 다른 액션이 뒤에 올 것이라고 기대한다. 그래서 가장 마지막 액션은 <-를 가지지 않는다.

### 액션의 타입을 다시 염두에 둬보자

        putStrLn :: String -> IO ()
        getLine  :: IO String

타입의 기초에서 배운 사고 방식을 그대로 활용해서 어떻게 틀린 건지를 밝혀낼 수 있다. 간단히 설명하면, putStrLn은 입력으로 String을 기대한다. 우리가 가지고 있는 것은 String이 아니라 감질나게 비슷한 IO String다. IO String은 실행되면 String을 돌려주는 액션을 나타낸다. putStrLn이 원하는 String을 얻으려면, 액션을 실행한 다음, 참 편리한 왼쪽 화살표 <-를 이용해야 한다. 그럼 `<-`는 액션의 결과값에 대해서만 사용할 수 있다는 건강?

`<-`를 쓰고 싶어 정규 String을 IO String으로 바꾸고 싶다면, `return`이라는 특수코드를 이용할 수도있다. IO와 호환되게끔 도와주는 느낌? 또는 `let` 바인딩을 써서 `=`과 함께 써줄 수도 있겠다. `do` 블록 내의 `let` 바인딩은 `in` 키워드가 필요하지 않다. 


---

<br />

### (참고) Multi-line commands in GHCi

        :{
            ...
        :}

할 수도 있고, 그냥 `;` 써도 되는 듯 하다. 

<br />

## Terms

<br />

- 프롬프트

컴퓨터 터미널의 CLI(Command-line interface, 가상 터미널 또는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식)의 명령줄 대기모드를 가리킴. 컴퓨터가 입력을 기다리고 있음을 가리키기 위해 화면에 나타나는 표시
